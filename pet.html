<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>moyuking 摸鱼小鱼</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
        user-select: none;
      }

      .pet-container {
        position: relative;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      /* 数据展示区域 */
      .data-panel {
        position: absolute;
        top: 8px;
        left: 8px;
        right: 8px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 11px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        pointer-events: auto;
        z-index: 10;
        backdrop-filter: blur(10px);
      }

      .data-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 4px 0;
        color: #333;
      }

      .data-label {
        color: #666;
        font-weight: 500;
      }

      .data-value {
        color: #1890ff;
        font-weight: 600;
      }

      .level-badge {
        display: inline-block;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 10px;
        font-weight: 600;
      }

      /* 进度条 */
      .progress-bar {
        width: 100%;
        height: 4px;
        background: #e8e8e8;
        border-radius: 2px;
        margin-top: 6px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 2px;
        transition: width 0.3s ease;
      }

      /* 鱼儿容器 */
      .pet-wrapper {
        position: absolute;
        width: 180px;
        height: 180px;
        pointer-events: auto;
        cursor: default;
        transition: transform 0.1s linear;
      }

      .pet {
        width: 100%;
        height: 100%;
        background-image: url('./fish.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
      }

      .pet:hover {
        transform: scale(1.1);
        filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.3));
      }
    </style>
  </head>
  <body>
    <div class="pet-container">
      <!-- 数据展示面板 -->
      <div class="data-panel" id="dataPanel">
        <div class="data-row">
          <span class="data-label">今日摸鱼</span>
          <span class="data-value" id="dailyTime">0秒</span>
        </div>
        <div class="data-row">
          <span class="data-label">累计摸鱼</span>
          <span class="data-value" id="totalTime">0秒</span>
        </div>
        <div class="data-row">
          <span class="data-label">成长值</span>
          <span class="data-value" id="growthValue">0</span>
        </div>
        <div class="data-row">
          <span class="data-label">等级</span>
          <span class="level-badge" id="level">Lv.1</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
      </div>

      <!-- 鱼儿 -->
      <div class="pet-wrapper" id="petWrapper">
        <div class="pet" id="pet"></div>
      </div>
    </div>

    <script>
      // 格式化时间（秒转时分秒）
      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        
        if (hours > 0) {
          return `${hours}时${minutes}分${secs}秒`;
        } else if (minutes > 0) {
          return `${minutes}分${secs}秒`;
        } else {
          return `${secs}秒`;
        }
      }

      // 计算等级进度（0-100%）
      function calculateLevelProgress(growthValue, level) {
        const levelThresholds = [0, 60, 300, 600, 1200, Infinity];
        if (level >= 5) return 100;
        
        const currentThreshold = levelThresholds[level - 1];
        const nextThreshold = levelThresholds[level];
        const progress = ((growthValue - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
        return Math.max(0, Math.min(100, progress));
      }

      // 更新UI
      function updateUI(data) {
        const { dailyTime, totalTime, growthValue, level } = data;
        
        document.getElementById('dailyTime').textContent = formatTime(dailyTime);
        document.getElementById('totalTime').textContent = formatTime(totalTime);
        document.getElementById('growthValue').textContent = growthValue;
        document.getElementById('level').textContent = `Lv.${level}`;
        
        const progress = calculateLevelProgress(growthValue, level);
        document.getElementById('progressFill').style.width = `${progress}%`;
        
        // 根据等级调整鱼儿大小
        const baseSize = 80;
        const sizePerLevel = 20;
        const maxSize = 180;
        const size = Math.min(baseSize + (level - 1) * sizePerLevel, maxSize);
        const petWrapper = document.getElementById('petWrapper');
        petWrapper.style.width = `${size}px`;
        petWrapper.style.height = `${size}px`;
      }

      // 初始化数据
      async function initData() {
        if (window.electronAPI && window.electronAPI.getMoyuData) {
          try {
            const data = await window.electronAPI.getMoyuData();
            updateUI(data);
          } catch (e) {
            console.error('[Pet] Failed to get moyu data:', e);
          }
        }
      }

      // 监听数据更新事件
      window.addEventListener('moyu-data-updated', (event) => {
        if (event.detail) {
          updateUI(event.detail);
        }
      });

      // 游动系统
      class SwimmingSystem {
        constructor() {
          this.petWrapper = document.getElementById('petWrapper');
          this.container = document.querySelector('.pet-container');
          this.x = 0;
          this.y = 0;
          this.targetX = 0;
          this.targetY = 0;
          this.velocityX = 0;
          this.velocityY = 0;
          this.speed = 0.5; // 游动速度
          this.boundaryPadding = 20; // 边界内边距
          this.mouseFollowTimer = null;
          this.mouseX = 0;
          this.mouseY = 0;
          this.isFollowingMouse = false;
          
          this.init();
        }

        init() {
          // 获取窗口尺寸（pet窗口的实际大小）
          const windowWidth = window.innerWidth || 220;
          const windowHeight = window.innerHeight || 280;
          
          // 初始位置（窗口内随机位置，避开数据面板区域）
          this.x = Math.random() * (windowWidth - 180) + 20;
          this.y = Math.random() * (windowHeight - 180) + 100; // 避开顶部数据面板
          
          // 设置初始目标位置
          this.targetX = this.x;
          this.targetY = this.y;
          
          // 监听鼠标移动（相对于窗口）
          document.addEventListener('mousemove', (e) => {
            this.mouseX = e.clientX;
            this.mouseY = e.clientY;
          });
          
          // 开始游动
          this.startSwimming();
          
          // 每10秒尝试跟随鼠标一次
          this.mouseFollowTimer = setInterval(() => {
            this.tryFollowMouse();
          }, 10000);
        }

        // 尝试跟随鼠标
        tryFollowMouse() {
          if (Math.random() < 0.5) { // 50%概率跟随鼠标
            this.isFollowingMouse = true;
            const petSize = parseInt(this.petWrapper.style.width) || 80;
            this.targetX = this.mouseX - petSize / 2; // 调整到鱼儿中心
            this.targetY = this.mouseY - petSize / 2;
            
            // 5秒后停止跟随，恢复随机游动
            setTimeout(() => {
              this.isFollowingMouse = false;
              this.setRandomTarget();
            }, 5000);
          } else {
            this.setRandomTarget();
          }
        }

        // 设置随机目标位置
        setRandomTarget() {
          if (this.isFollowingMouse) return;
          
          const windowWidth = window.innerWidth || 220;
          const windowHeight = window.innerHeight || 280;
          const petSize = parseInt(this.petWrapper.style.width) || 80;
          
          // 随机目标位置（考虑边界，避开顶部数据面板区域）
          const minY = 100; // 数据面板下方
          this.targetX = this.boundaryPadding + Math.random() * (windowWidth - petSize - this.boundaryPadding * 2);
          this.targetY = minY + Math.random() * (windowHeight - minY - petSize - this.boundaryPadding);
        }

        // 边界检测和修正
        checkBoundaries() {
          const windowWidth = window.innerWidth || 220;
          const windowHeight = window.innerHeight || 280;
          const petSize = parseInt(this.petWrapper.style.width) || 80;
          const minY = 100; // 数据面板下方
          
          if (this.x < this.boundaryPadding) {
            this.x = this.boundaryPadding;
            this.targetX = this.x + Math.random() * 100;
          }
          if (this.x > windowWidth - petSize - this.boundaryPadding) {
            this.x = windowWidth - petSize - this.boundaryPadding;
            this.targetX = this.x - Math.random() * 100;
          }
          if (this.y < minY) {
            this.y = minY;
            this.targetY = this.y + Math.random() * 100;
          }
          if (this.y > windowHeight - petSize - this.boundaryPadding) {
            this.y = windowHeight - petSize - this.boundaryPadding;
            this.targetY = this.y - Math.random() * 100;
          }
        }

        // 更新位置
        update() {
          // 计算到目标位置的距离
          const dx = this.targetX - this.x;
          const dy = this.targetY - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // 如果到达目标位置，设置新的随机目标
          if (distance < 10 && !this.isFollowingMouse) {
            this.setRandomTarget();
          }
          
          // 使用缓动函数平滑移动
          this.velocityX += (this.targetX - this.x) * 0.02;
          this.velocityY += (this.targetY - this.y) * 0.02;
          
          // 应用速度
          this.x += this.velocityX * this.speed;
          this.y += this.velocityY * this.speed;
          
          // 阻尼（减少速度）
          this.velocityX *= 0.95;
          this.velocityY *= 0.95;
          
          // 边界检测
          this.checkBoundaries();
          
          // 更新DOM位置
          this.petWrapper.style.left = `${this.x}px`;
          this.petWrapper.style.top = `${this.y}px`;
          
          // 根据移动方向翻转鱼儿（可选）
          if (this.velocityX > 0.1) {
            this.petWrapper.style.transform = 'scaleX(1)';
          } else if (this.velocityX < -0.1) {
            this.petWrapper.style.transform = 'scaleX(-1)';
          }
        }

        // 开始游动循环
        startSwimming() {
          const animate = () => {
            this.update();
            requestAnimationFrame(animate);
          };
          animate();
        }
      }

      // 页面加载完成后初始化
      window.addEventListener('DOMContentLoaded', () => {
        initData();
        
        // 每秒更新一次数据（作为事件监听的备用）
        setInterval(() => {
          initData();
        }, 1000);
        
        // 初始化游动系统
        new SwimmingSystem();
      });
    </script>
  </body>
</html>
